; Подключаем заголовок библиотеки Famicom/NES/Денди
.include "src/neslib.inc"
; Подключаем заголовок библиотеки маппера MMC3
.include "src/mmc3.inc"

; Сегмент векторов прерываний и сброса/включения - находится в самых
; последних шести байтах адресного пространства процессора ($FFFA-FFFF)
; и содержит адреса по которым процессор переходит при наступлении события
.segment "VECTORS"	
	.addr nmi	; Вектор прерывания NMI (процедура nmi ниже)
	.addr reset	; Вектор сброса/включения (процедура reset ниже)
	.addr irq	; Вектор прерывания IRQ (процедура irq ниже)

.segment "ZPAGE": zp	; Сегмент zero page, это надо пометить через ": zp"
vblank_counter:	.byte 0	; Счётчик прерываний VBlank
glob_temp0:	.byte 0	; Байт ультравременных данных в zero-page

far_jsr_page:	.byte 0	; Страница на которую надо перейти межстраничным переходом
far_jsr_addr:	.word 0	; Адрес на который надо перейти межстраничным переходом
; set_far_dest - макрос выставления страницы и адреса для межстраничного перехода
.macro set_far_dest ppage, paddr
	store		far_jsr_page, ppage	; сохраним страницу
	store_addr	far_jsr_addr, paddr	; сохраним адрес
.endmacro

.segment "RAM"		; Сегмент неинициализированных данных в RAM

.segment "ROM_0"	; Страница данных 0 (первые 8Кб из 64 ROM картриджа) для адреса $8000
	.byte $00	; Первый байт - номер страницы
	.byte "This is the first page to show. ", 0	; Строка текста

.segment "ROM_1"	; Страница данных 1 (вторые 8Кб из 64 ROM картриджа) для адреса $8000
	.byte $01	; номер страницы
	.byte "And this is text from second one", 0	; Строка текста

.segment "ROM_2"	; Страница данных 2...
	.byte $02	; номер страницы
	.byte "Third is filled with this...    ", 0

.segment "ROM_3"	; Страница данных 3...
	.byte $03	; номер страницы
	.byte "And nothing is wrong with fourth", 0

.segment "ROM_4"	; Страница кода 4 (пятые 8Кб из 64 ROM картриджа) для адреса $A000
	.byte $04	; номер страницы
	
; print_some1 - процедура вывода строки с текстом по адресу $8001 на экран
; Главное что мы тут демонстрируем - это то, что процедура эта находясь в странице $04
; будет вызывать другую процедуру из страницы $05.
.proc print_some
	locate_in_vpage PPU_SCR0, 0, 3	; Позиционируемся на символ (0,3) в SCR0
	ldy # 0		; Обнуляем индексный регистр Y
fill_loop:
	lda $8001, y	; Загружаем A из адреса ($8001+Y)
	beq end		; если загруженный байт нулевой - идём на выход
	sta PPU_DATA	; иначе сохраняем его в VRAM
	iny		; инкрементируем Y
	jmp fill_loop	; и возвращаемся в цикл
end:	
	; В конце настроим адрес дальнего межстраничного перехода на процедуру
	; inc_some находящуюся в странице $05 и вызовем её межстраничным переходом.
	set_far_dest # 5, inc_some	; сохраним адрес перехода в zero-page
	jsr far_jsr	; и перейдём на процедуру межстраничного перехода
	rts		; возврат из процедуры
.endproc

.segment "ROM_5"	; Страница кода 5 (шестые 8Кб из 64 ROM картриджа) для адреса $A000
	.byte $05	; номер страницы

; inc_some - процедура инкрементирующая символ в SCR0
; Главное что тут демонстрируется - что она сама находясь в странице кода 5 
; в адресах $A000-BFFF вызывается из страницы код 4 по тем же адресам с помощью
; переключения банков маппером и возвращается куда надо.
.proc inc_some
	; Споцизионируемся на символ (10,10) в SCR0
	locate_in_vpage PPU_SCR0, 10, 10
	ldx PPU_DATA	; Первое считывание из VRAM - "холостое"
	ldx PPU_DATA	; Второе считывание даст значение байта по адресу
	; Снова позиционируемся на том же символе
	locate_in_vpage PPU_SCR0, 10, 10
	inx		; увеличиваем его предыдущее значение
	stx PPU_DATA	; и сохраняем обратно в VRAM
	rts		; Возврат из процедуры
.endproc

; С MMC3 в сегменте ROM_H у нас располагаются последние страницы ROM картриджа
; т.е. в данной конфигурации с 64Кб ROM - 6 и 7 по порядку.
.segment "ROM_H"	; Сегмент данных в ПЗУ картриджа (страницы $C000-$FFFF)
palettes:		; Подготовленные наборы палитр (для фона и для спрайтов)
	; Повторяем наборы 2 раза - первый для фона и второй для спрайтов
	.repeat 2	
	.byte $0F, $00, $10, $20	; Черный, серый, светло-серый, белый
	.byte $0F, $16, $1A, $11	; -, красный, зеленый, синий
	.byte $0F, $1A, $11, $16	; -, зеленый, синий, красный
	.byte $0F, $11, $16, $1A	; -, синий, красный, зеленый
	.endrep
  
.segment "ROM_H"	; Сегмент кода в ПЗУ картриджа (страницы $C000-$FFFF)

; irq - процедура обработки прерывания IRQ
; Пока сразу же возвращается из прерывания как заглушка.
.proc irq
	rti		; Инструкция возврата из прерывания
.endproc

; nmi - процедура обработки прерывания NMI
; Обрабатывает наступление прерывания VBlank от PPU (см. процедуру wait_nmi)
.proc nmi
	inc vblank_counter	; Просто увеличим vblank_counter
	rti			; Возврат из прерывания
.endproc

; wait_nmi - ожидание наступления прерывания VBlank от PPU
; Согласно статье https://wiki.nesdev.com/w/index.php/NMI ожидание VBlank
; опросом верхнего бита PPU_STATUS в цикле может пропускать целые кадры из-за
; специфической гонки состояний, поэтому правильнее всего перехватывать прерывание,
; в нём наращивать счётчик (процедура nmi выше) и ожидать его изменения как в коде ниже.
.proc wait_nmi
	lda vblank_counter
notYet:	cmp vblank_counter
	beq notYet
	rts
.endproc

; fill_palettes - заполнить все наборы палитр данными из адреса в памяти
; вход:
;	arg0w - адрес таблицы с набором палитр (2 * 4 * 4 байта)
.proc fill_palettes
	fill_ppu_addr $3F00	; палитры в VRAM находятся по адресу $3F00
	ldy # 0			; зануляем счётчик и одновременно индекс
loop:
	lda (arg0w), y		; сложный режим адресации - к слову лежащему в zero page
				; по однобайтовому адресу arg0w прибавляется Y и 
				; в A загружается байт из полученного адреса
	sta PPU_DATA		; сохраняем в VRAM
	iny			; инкрементируем Y
	cpy # 2 * 4 * 4		; проверяем на выход за границу цикла
	bne loop		; и зацикливаемся если она еще не достигнута
	rts			; выходим из процедуры
.endproc

; fill_attribs - заполнить область цетовых атрибутов байтом в аккумуляторе
; адрес в PPU_ADDR уже должен быть настроен на эту область атрибутов!
.proc fill_attribs
	ldx # 64		; надо залить 64 байта цветовых атрибутов
loop:	sta PPU_DATA		; записываем в VRAM аккумулятор
	dex			; декрементируем X
	bne loop		; цикл по счётчику в X
	rts			; возврат из процедуры
.endproc

; far_jsr - вызов процедуры из нетекущего банка памяти
; вход: far_jsr_page - страница памяти где находится процедура
; 	far_jsr_addr - адрес процедуры внутри сегмента PRG_H1
; Регистры как на входе в процедуру так и на выходе из неё не портятся.
.proc far_jsr
	sta glob_temp0		; Сохраним A во времянку.
	lda $A000 		; Возьмём текущий селектор страницы в PRG_H1
	pha			; и сохраним в стек.
	lda # MMC3_PRG_H1	; Выбираем банк PRG_H1
	sta MMC3_BANK		; в порту ввода-вывода MMC3_BANK.
	lda far_jsr_page	; Загружаем страницу процедуры в A,
	sta MMC3_PAGE		; Активируем эту страницу в текущем банке
	lda glob_temp0		; Восстановим A из glob_temp0
	jsr invoke		; Переходим на активатор процедуры через jsr чтобы
				; возврат произошёл на следующую инструкцию
	sta glob_temp0		; Сохраним возвращённый из процедуры A во времянке
	lda # MMC3_PRG_H1	; Выбираем банк PRG_H1
	sta MMC3_BANK		; в порту MMC3_BANK.
	pla			; Восстанавливаем старую страницу из стека в A
	sta MMC3_PAGE		; Активируем её записью в порт MMC3_PAGE
	lda glob_temp0		; Восстанавливаем возвращённый процедурой аккумулятор
	rts			; и выходим.
invoke:	jmp (far_jsr_addr)	; Косвенный переход на адрес хранимый в far_jsr_addr
.endproc

; reset - стартовая точка всей программы - диктуется вторым адресом в сегменте 
; VECTORS оформлена как процедура, но вход в неё происходит при включении консоли 
; или сбросу её по кнопке RESET, поэтому ей некуда "возвращаться" и она 
; принудительно инициализирует память и стек чтобы работать с чистого листа.
.proc reset
	; ***********************************************************
	; * Первым делом нужно привести систему в рабочее состояние *
	; ***********************************************************
	sei			; запрещаем прерывания
	ldx # $FF		; чтобы инициализировать стек надо записать $FF в X
	txs			; и передать его в регистр вершины стека командой 
				; Transfer X to S (txs)
	
	sta MMC3_IRQ_OFF	; Выключим IRQ маппера
	
	; Теперь можно пользоваться стеком, например вызывать процедуры
	jsr warm_up		; вызовем процедуру "разогрева" (см. neslib.s)
	
	store_addr arg0w, palettes	; параметр arg0w = адрес наборов палитр
	jsr fill_palettes	; вызовем процедуру копирования палитр в PPU
	
	fill_page_by PPU_SCR0, # 7	; зальём SCR0 тайлом №7
	fill_ppu_addr PPU_SCR0_ATTRS	; настроим PPU_ADDR на атрибуты SCR0
	lda # 0				; выберем в A нулевую палитру
	jsr fill_attribs		; и зальём её область атрибутов SCR0
	
	; Предварительно выставим банки памяти PPU просто по порядку
	mmc3_set_bank_page # MMC3_CHR_H0, # 0
	mmc3_set_bank_page # MMC3_CHR_H1, # 2
	mmc3_set_bank_page # MMC3_CHR_Q0, # 4
	mmc3_set_bank_page # MMC3_CHR_Q1, # 5
	mmc3_set_bank_page # MMC3_CHR_Q2, # 6
	mmc3_set_bank_page # MMC3_CHR_Q3, # 7
	
	; Предварительно выставим банки памяти CPU
	mmc3_set_bank_page # MMC3_PRG_H0, # 0	; В банке данных выберем страницу 0
	mmc3_set_bank_page # MMC3_PRG_H1, # 5	; В банке кода выберем страницу 5
	
	store MMC3_MIRROR, # MMC3_MIRROR_V	; Выставим вертикальное зеркалирование
	store MMC3_RAM_PROTECT, # 0		; Отключим RAM (если бы она даже была)
	
	; Отключим все спрайты выводом их за границу отрисовки по Y
	ldx # 0		; В X разместим указатель на текущий спрайт
	lda # $FF	; В A координата $FF по Y
sz_loop:	
	sta SPR_TBL, x	; Сохраним $FF в координату Y текущего спрайта
	inx
	inx
	inx
	inx		; И перейдём к следующему
	bne sz_loop	; Если X не 0, то идём на следующую итерацию
	
	; **********************************************
	; * Стартуем видеочип и запускаем все процессы *
	; **********************************************
	; Включим генерацию прерываний по VBlank и источником тайлов для спрайтов
	; сделаем второй банк видеоданных где у нас находится шрифт.
	store PPU_CTRL, # PPU_VBLANK_NMI | PPU_SPR_TBL_1000
	; Включим отображение спрайтов и то что они отображаются в левых 8 столбцах пикселей
	store PPU_MASK, # PPU_SHOW_BGR | PPU_SHOW_LEFT_BGR | PPU_SHOW_SPR | PPU_SHOW_LEFT_SPR
	cli			; Разрешаем прерывания
	
	; ***************************
	; * Основной цикл программы *
	; ***************************
main_loop:
	jsr wait_nmi		; ждём наступления VBlank

	; Чтобы обновить таблицу спрайтов в видеочипе надо записать в OAM_ADDR ноль
	store OAM_ADDR, # 0
	; И активировать DMA записью верхнего байта адреса страницы с описаниями
	store OAM_DMA, # >SPR_TBL

	lda $8000		; загрузим в A номер страницы в банке PRG_H0
	sta arg0b		; сохраним его в arg0b
	; если не нажата KEY_A - идём дальше
	jump_if_keys1_was_not_pressed KEY_A, skip_A
	inc arg0b		; иначе инкрементируем arg0b
skip_A:
	; если не нажата KEY_B - идём дальше
	jump_if_keys1_was_not_pressed KEY_B, skip_B
	dec arg0b		; иначе декрементируем arg0b
skip_B:
	lda # 3		; загружаем в A 3,
	and arg0b	; накладываем по AND с arg0b (т.е. оставляем только 2 нижних бита)
	sta arg0b	; и сохраняем обратно в arg0b (замкнули значение в диапазоне 0-3)
	; Выставляем текущей страницей в PRG_H0 значение в arg0b
	mmc3_set_bank_page # MMC3_PRG_H0, arg0b
	
	set_far_dest # 4, print_some	; выставим банк 4 и адрес print_some как
					; цель межстраничного перехода
	jsr far_jsr			; и совершим межстраничный переход
	
	store PPU_SCROLL, # 0	; Перед началом кадра выставим скроллинг
	store PPU_SCROLL, # 0	; в (0, 0) чтобы панель рисовалась фиксированно
	
	; ********************************************************
	; * После работы с VRAM можно заняться другими вещами... *
	; ********************************************************

	jsr update_keys		; Обновим состояние кнопок опросив геймпады

	jmp main_loop		; И уходим ждать нового VBlank в бесконечном цикле
.endproc
