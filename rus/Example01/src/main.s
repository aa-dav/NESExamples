; Подключаем заголовок библиотеки Famicom/NES/Денди
.include "src/neslib.inc"

; Сегмент векторов прерываний и сброса/включения - находится в самых
; последних шести байтах адресного пространства процессора ($FFFA-FFFF)
; и содержит адреса по которым процессор переходит при наступлении события
.segment "VECTORS"	
	.addr nmi	; Вектор прерывания NMI (процедура nmi ниже)
	.addr reset	; Вектор сброса/включения (процедура reset ниже)
	.addr irq	; Вектор прерывания IRQ (процедура irq ниже)

.segment "ZPAGE": zp	; Сегмент zero page, это надо пометить через ": zp"
vblank_counter:	.byte 0	; Счётчик прерываний VBlank

.segment "RAM"		; Сегмент неинициализированных данных в RAM
ppu_ctrl_last:	.byte 0	; Последнее записанное в порт PPU_CTRL значение
xscroll:	.byte 0	; Скроллинг по X (в пределах базовой видеостраницы)
yscroll:	.byte 0	; Скроллинг по Y (в пределеах базовой видеостраницы)
update_addr:	.word 0	; Текущий адрес в VRAM бегущей строки обновления символов

.segment "ROM_L"	; Сегмент данных в ПЗУ картриджа (страницы $C000-$FFFF)
palettes:		; Подготовленные наборы палитр (для фона и для спрайтов)
	; Повторяем наборы 2 раза - первый для фона и второй для спрайтов
	.repeat 2	
	.byte $0F, $00, $10, $20	; Черный, серый, светло-серый, белый
	.byte $0F, $16, $1A, $11	; Чёрный, красный, зеленый, синий
	.byte $0F, $00, $10, $20	; Эта палитра и ниже здесь не используются
	.byte $0F, $00, $10, $20
	.endrep
  
.segment "ROM_H"	; Сегмент кода в ПЗУ картриджа (страницы $C000-$FFFF)

; irq - процедура обработки прерывания IRQ
; Пока сразу же возвращается из прерывания как заглушка.
.proc irq
	rti		; Инструкция возврата из прерывания
.endproc

; nmi - процедура обработки прерывания NMI
; Обрабатывает наступление прерывания VBlank от PPU (см. процедуру wait_nmi)
.proc nmi
	inc vblank_counter	; Просто увеличим vblank_counter
	rti			; Возврат из прерывания
.endproc

; wait_nmi - ожидание наступления прерывания VBlank от PPU
; Согласно статье https://wiki.nesdev.com/w/index.php/NMI ожидание VBlank
; опросом верхнего бита PPU_STATUS в цикле может пропускать целые кадры из-за
; специфической гонки состояний, поэтому правильнее всего перехватывать прерывание,
; в нём наращивать счётчик (процедура nmi выше) и ожидать его изменения как в коде ниже.
.proc wait_nmi
	lda vblank_counter
notYet:	cmp vblank_counter
	beq notYet
	rts
.endproc

; fill_palettes - заполнить все наборы палитр данными из адреса в памяти
; вход:
;	arg0w - адрес таблицы с набором палитр (2 * 4 * 4 байта)
.proc fill_palettes
	fill_ppu_addr $3F00	; палитры в VRAM находятся по адресу $3F00
	ldy # 0			; зануляем счётчик и одновременно индекс
loop:
	lda (arg0w), y		; сложный режим адресации - к слову лежащему в zero page
				; по однобайтовому адресу arg0w прибавляется Y и 
				; в A загружается байт из полученного адреса
	sta PPU_DATA		; сохраняем в VRAM
	iny			; инкрементируем Y
	cpy # 2 * 4 * 4		; проверяем на выход за границу цикла
	bne loop		; и зацикливаемся если она еще не достигнута
	rts			; выходим из процедуры
.endproc

; fill_attribs - заполнить область цетовых атрибутов байтом в аккумуляторе
; адрес в PPU_ADDR уже должен быть настроен на эту область атрибутов!
.proc fill_attribs
	ldx # 64		; надо залить 64 байта цветовых атрибутов
loop_colors:
	sta PPU_DATA		; записываем в VRAM аккумулятор
	dex			; декрементируем X
	bne loop_colors		; цикл по счётчику в X
	rts			; возврат из процедуры
.endproc

; reset - стартовая точка всей программы - диктуется вторым адресом в сегменте 
; VECTORS оформлена как процедура, но вход в неё происходит при включении консоли 
; или сбросу её по кнопке RESET, поэтому ей некуда "возвращаться" и она 
; принудительно инициализирует память и стек чтобы работать с чистого листа.
.proc reset
	; ***********************************************************
	; * Первым делом нужно привести систему в рабочее состояние *
	; ***********************************************************
	sei			; запрещаем прерывания
	ldx # $FF		; чтобы инициализировать стек надо записать $FF в X
	txs			; и передать его в регистр вершины стека командой 
				; Transfer X to S (txs)
	; Теперь можно пользоваться стеком, например вызывать процедуры
	jsr warm_up		; вызовем процедуру "разогрева" (см. neslib.s)
	
	store_addr arg0w, palettes	; параметр arg0w = адрес наборов палитр
	jsr fill_palettes	; вызовем процедуру копирования палитр в PPU
	
	; **************************************************************************
	; * Зальём первую видеостраницу расходящимся веером символов начиная с '0' *
	; **************************************************************************
	fill_ppu_addr $2000	; Будем писать в видеостраницу $2000
	; Нам нужны переменные текущей строки (cur_y) и текущего столбца (cur_x)
	; сиволов экрана - для самоописуемости назначаем их как синонимы ячеек
	; памяти в локальных переменных zero page.
cur_x	= arg0b			; текущий столбец (0-31)
cur_y	= arg1b			; текущая строка (0-29) (всего 32*30 символов/тайлов)
	store cur_x, # 0	; cur_x = 0
	store cur_y, # 0	; cur_y = 0
loop_fill:
	lda cur_x		; Сравниваем loc_x (помещённый в A)
	cmp cur_y		; с loc_y и если loc_y > loc_x, то
	bcc cur_y_bigger	; флас Carry будет 0 и тогда мы пропустим
	lda cur_y		; загрузку loc_y в A, т.е. A = min( loc_x, loc_y )
cur_y_bigger:
	clc			; Перед сложением надо сбросить Carry
	adc # $30		; $30 - это символ '0', сложение A даст расходящийся 
				; веер символов вдоль осей.
	sta PPU_DATA		; Сохраним итоговый символ в VRAM
	inc cur_x		; Увеличиваем loc_x
	lda # 32		; и сравниваем его
	cmp cur_x		; с 32 (концом столбцов в текущей строке)
	bne loop_fill		; и если не равны, то новая итерация.
	store cur_x, # 0	; Обнуляем loc_x (сброс итераций по этой переменной)
	inc cur_y		; и увеличиваем loc_y
	lda # 30		; сравнивая его с
	cmp cur_y		; 30 (концом строк)
	bne loop_fill		; и если конец не достигнут - новая итерация.
	
	lda # 0			; атрибуты цвета в палитру 0
	jsr fill_attribs	; заполним оставшуюся область цветовых атрибутов

	; *************************************************************************
	; * Зальём вторую видеостраницу нарастающими по алфавиту символами текста *
	; *************************************************************************
	fill_ppu_addr $2400	; настроим PPU_ADDR на $2400
	ldy # $20		; $20 - это ASCII код пробела в таблице символов
				; и в тестом банке CHR он же номер тайла пробела
	ldx # 32 * 30 / 4	; нужно залить 32*30 тайлов, но чтобы счётчик цикла
				; влез в байт будем сразу лить порциями по 4 тайла
loop_tiles:
	.repeat 4		; код между .repeat и .endrep размножится 4 раза подряд...
	sty PPU_DATA		; сохраняем код символа в VRAM
	iny			; и переходим к следующему символу
	.endrep
	cpy # 80		; сравниваем с концом таблицы символов
	bne loop_skip		; и если конец символов не достигнут, то пропускаем...
	ldy # $20		; сброс опять на ASCII-код пробела
loop_skip:
	dex			; декрементируем счётчик
	bne loop_tiles		; и если он не ноль, то повторяем цикл

	lda # %01010101		; атрибуты цвета в палитру 1
	jsr fill_attribs	; заполним область цветовых атрибутов
	
	; **********************************************
	; * Стартуем видеочип и запускаем все процессы *
	; **********************************************
	; Включим отображение заднего фона (отложим в ppu_ctrl_last)
	store ppu_ctrl_last, # PPU_VBLANK_NMI | PPU_BGR_TBL_1000
	; Обновив ppu_ctrl_last теперь записываем его в PPU_CTRL для применения
	store PPU_CTRL, ppu_ctrl_last
	; Включим отображение заднего фона и левой колонки его пикселей на экране
	store PPU_MASK, # PPU_SHOW_BGR | PPU_SHOW_LEFT_BGR
	cli			; Разрешаем прерывания
	
	store xscroll, # 0	; скроллинг по X и Y инициализируем в 0
	store yscroll, # 0
	store_addr update_addr, $2400	; начальный адрес инкрементации VRAM
	
	; ***************************
	; * Основной цикл программы *
	; ***************************
main_loop:
	jsr wait_nmi		; ждём наступления VBlank

	; ********************************************************************************
	; * Каждый кадр увеличим символ во второй видеостранице и переходим к следующему *
	; ********************************************************************************
	; выставим в PPU_ADDR адрес update_addr для считывания номера тайла
	store PPU_ADDR, update_addr + 1	; сперва старший байт
	store PPU_ADDR, update_addr + 0
	; (!) Заметьте, что выше мы не могли использовать fill_ppu_addr update_addr, т.к.
	; надо чётко понимать разницу между адресом и значением которое по адресу лежит.
	ldx PPU_DATA		; первое чтение из PPU_DATA после смены PPU_ADDR надо игнорировать
	ldx PPU_DATA		; читаем номер тайла/символа в X
	inx			; увеличиваем его
	cpx # $80		; проверяем на выход за максимальный символ (ASCII $80)
	bne skip_x20		; если не вышел - идём дальше
	ldx # $20		; иначе откатываем символ в пробел
skip_x20:			; снова выставляем адрес PPU_DATA т.к. он ушёл вперёд
	store PPU_ADDR, update_addr + 1
	store PPU_ADDR, update_addr + 0
	stx PPU_DATA		; сохраняем инкрементированный символ в VRAM
	
	inc update_addr + 0	; увеличиваем младший байт адреса update_addr
	bne skip_inc_high	; если он не обнулился, то пропускаем
	inc update_addr + 1	; увеличение старшего адреса update_addr
skip_inc_high:
	ldx # $C0		; чтобы проверить не равен ли update_addr адресу $27C0
	cpx update_addr + 0	; сперва сверяем нижний его байт с $C0
	bne end_of_updater	; если не равно - идём дальше
	ldx # $27		; иначе сверяем верхний байт с $27
	cpx update_addr + 1	
	bne end_of_updater	; и если не равно - идём дальше
	; если же update_addr стал равен $27C0 (конец тайлов экрана), то сбрасываем его в начало
	store_addr update_addr, $2400
end_of_updater:

	; *************************************************************
	; * Если нажат SELECT, то сбросим параметры прокрутки в (0,0) *
	; *************************************************************
	; С помощью макроса skip_if_key1_not пропускаем куски кода
	; если не нажата соответствующая кнопка. Здесь - KEY_SELECT
	jump_if_keys1_is_not_down KEY_SELECT, skip_scroll_reset
	store xscroll, # 0	; Занулили параметры прокрутки
	store yscroll, # 0	; в пределах текущего экрана...
	lda ppu_ctrl_last	; А верхние биты прокрутки (или они же - выбор
	and # %11111100		; текущего экрана из четырёх) надо занулить в PPU_CTRL
	sta ppu_ctrl_last	; для чего сбросим их битовой операцией в ppu_ctrl_last.
skip_scroll_reset:

	; *************************************************************
	; * Скроллимся в соответствии с нажатыми кнопками направлений *
	; *************************************************************
swap_x	= arg0b	; Сделаем псевдонимы для переменных: нужно ли изменить верхние биты 
swap_y	= arg1b	; параметров прокрутки по X и Y в ppu_ctrl_last после скроллинга
	store swap_x, # 0	; Верхний бит swap_x будет флагом по X
	store swap_y, # 0	; Верхний бит swap_y будет флагом по Y
	; Если нажата кнопка ВЛЕВО, то надо уменьшить скролл по X
	jump_if_keys1_is_not_down KEY_LEFT, skip_l	; Идём дальше если кнопка не нажата
	dec xscroll		; пока просто уменьшаем xscroll
	lda # $FF		; и проверяем не провернулся ли он через 0
	cmp xscroll		; и не стал ли тогда $FF
	bne skip_l		; если нет, то идём дальше
	store swap_x, # $80	; а если да, то взводим флаг проворота экрана по X
skip_l:	; Если нажата кнопка ВПРАВО, то надо увеличить скролл по X
	jump_if_keys1_is_not_down KEY_RIGHT, skip_r	; Идём дальше если кнопка не нажата
	inc xscroll		; Увеличим xscroll
	bne skip_r		; Сразу можно тестировать на 0 и если он им не стал, то идём дальше
	store swap_x, # $80	; Иначе значит он "провернулся" из $FF->0 и надо взвести флаг по X
skip_r:	; Если нажата кнопка ВНИЗ, то надо увеличить скролл по Y
	jump_if_keys1_is_not_down KEY_DOWN, skip_d
	inc yscroll		; Увеличим yscroll
	lda # 240		; и проверям не стал ли он равен 240
	cmp yscroll
	bne skip_d		; если нет, то идём дальше
	store yscroll, # 0	; а если да, то надо обнулить yscroll
	store swap_y, # $80	; И взвести флаг проворота экрана по Y
skip_d:	; Если нажата кнопка ВВЕРХ, то надо уменьшить скролл по Y
	jump_if_keys1_is_not_down KEY_UP, skip_u
	dec yscroll		; Уменьшим yscroll
	lda # $FF		; И проверяем не провернулся ли он через 0
	cmp yscroll		; и не стал равным $FF
	bne skip_u		; если нет, то идём дальше
	store yscroll, # 239	; иначе загружаем в yscroll 239
	store swap_y, # $80	; и взводим флаг необходимости проворота экрана по Y
skip_u:	; Теперь можно применить флаги проворота экрана по X и Y если они взведены
	lda ppu_ctrl_last	; Нижние 2 бита ppu_ctrl_last - это то что нам возможно надо поменять
	bit swap_x		; Тестируем зажжён ли старший бит в swap_x
	bpl skip_inv_x		; если нет, то идём дальше (флаг не взведён)
	eor # %001		; иначе инвертируем (через XOR) 0-ой бит ppu_ctrl_last в A
skip_inv_x:	
	bit swap_y		; Тестируем зажжён ли старший бит в swap_y
	bpl skip_inv_y		; если нет, то идём дальше
	eor # %010		; иначе инвертируем (через XOR) 1-ый бит ppu_ctrl_last в A
skip_inv_y:
	sta ppu_ctrl_last	; Сохраняем возможно изменённый ppu_ctrl_last из аккумулятора

	; **************************************************
	; * Применяем все накопленные параметры скроллинга *
	; **************************************************
	store PPU_CTRL, ppu_ctrl_last	; Загружаем состояние PPU из ppu_ctrl_last
	store PPU_SCROLL, xscroll	; Обновляем параметры скроллинга
	store PPU_SCROLL, yscroll

	; ************************************************************
	; * После работы с VRAM можно заняться другими вещами        *
	; * чтобы не занимать ценное время VBlank ничем кроме этого. *
	; * Теперь можно, например, обновить состояние кнопок.       *
	; ************************************************************
	jsr update_keys		; Обновим состояние кнопок опросив геймпады
	
	jmp main_loop		; И уходим ждать нового VBlank в бесконечном цикле
.endproc
