; Подключаем заголовок библиотеки Famicom/NES/Денди
.include "src/neslib.inc"
; Подключаем заголовок библиотеки маппера MMC3
.include "src/mmc3.inc"

; Сегмент векторов прерываний и сброса/включения - находится в самых
; последних шести байтах адресного пространства процессора ($FFFA-FFFF)
; и содержит адреса по которым процессор переходит при наступлении события
.segment "VECTORS"	
	.addr nmi	; Вектор прерывания NMI (процедура nmi ниже)
	.addr reset	; Вектор сброса/включения (процедура reset ниже)
	.addr irq	; Вектор прерывания IRQ (процедура irq ниже)

.segment "ZPAGE": zp	; Сегмент zero page, это надо пометить через ": zp"
vblank_counter:	.byte 0	; Счётчик прерываний VBlank
next_page:	.byte 0	; Номер следующей видеостраницы к переключению

.segment "RAM"		; Сегмент неинициализированных данных в RAM

.segment "ROM_0"	; Страница данных 0 (первые 8Кб из 64 ROM картриджа) для адреса $8000
.segment "ROM_1"	; Страница данных 1 (вторые 8Кб из 64 ROM картриджа) для адреса $8000
.segment "ROM_2"	; Страница данных 2...
.segment "ROM_3"	; Страница данных 3...
.segment "ROM_4"	; Страница кода 4 (пятые 8Кб из 64 ROM картриджа) для адреса $A000
.segment "ROM_5"	; Страница кода 5 (шестые 8Кб из 64 ROM картриджа) для адреса $A000

; С MMC3 в сегменте ROM_H у нас располагаются последние страницы ROM картриджа
; т.е. в данной конфигурации с 64Кб ROM - 6 и 7 по порядку.
.segment "ROM_H"	; Сегмент данных в ПЗУ картриджа (страницы $C000-$FFFF)
palettes:		; Подготовленные наборы палитр (для фона и для спрайтов)
	; Повторяем наборы 2 раза - первый для фона и второй для спрайтов
	.repeat 2
	.byte $0F, $0A, $1A, $2A	; черный, тёмно-зеленый, зеленый, светло-зеленый
	.byte $0F, $16, $1A, $11	; -, красный, зеленый, синий
	.byte $0F, $1A, $11, $16	; -, зеленый, синий, красный
	.byte $0F, $11, $16, $1A	; -, синий, красный, зеленый
	.endrep
  
; nmi - процедура обработки прерывания NMI
; Обрабатывает наступление прерывания VBlank от PPU (см. процедуру wait_nmi)
.proc nmi
	inc vblank_counter	; Просто увеличим vblank_counter
	rti			; Возврат из прерывания
.endproc

; wait_nmi - ожидание наступления прерывания VBlank от PPU
; Согласно статье https://wiki.nesdev.com/w/index.php/NMI ожидание VBlank
; опросом верхнего бита PPU_STATUS в цикле может пропускать целые кадры из-за
; специфической гонки состояний, поэтому правильнее всего перехватывать прерывание,
; в нём наращивать счётчик (процедура nmi выше) и ожидать его изменения как в коде ниже.
.proc wait_nmi
	lda vblank_counter
notYet:	cmp vblank_counter
	beq notYet
	rts
.endproc

; fill_palettes - заполнить все наборы палитр данными из адреса в памяти
; вход:
;	arg0w - адрес таблицы с набором палитр (2 * 4 * 4 байта)
.proc fill_palettes
	fill_ppu_addr $3F00	; палитры в VRAM находятся по адресу $3F00
	ldy # 0			; зануляем счётчик и одновременно индекс
loop:
	lda (arg0w), y		; сложный режим адресации - к слову лежащему в zero page
				; по однобайтовому адресу arg0w прибавляется Y и 
				; в A загружается байт из полученного адреса
	sta PPU_DATA		; сохраняем в VRAM
	iny			; инкрементируем Y
	cpy # 2 * 4 * 4		; проверяем на выход за границу цикла
	bne loop		; и зацикливаемся если она еще не достигнута
	rts			; выходим из процедуры
.endproc

; fill_attribs - заполнить область цетовых атрибутов байтом в аккумуляторе
; адрес в PPU_ADDR уже должен быть настроен на эту область атрибутов!
.proc fill_attribs
	ldx # 64		; надо залить 64 байта цветовых атрибутов
loop:	sta PPU_DATA		; записываем в VRAM аккумулятор
	dex			; декрементируем X
	bne loop		; цикл по счётчику в X
	rts			; возврат из процедуры
.endproc

; fill_4_lines - заполнить в чересполосицу 8 строк страницы видеопамяти
; (указатель в PPU_ADDR уже должен быть настроен как надо)
; вход:
;	arg0b - начальный индекс с которого надо заполнять левую половину экрана
;	arg1b - начальный индекс с которого надо заполнять правую половину экрана
.proc fill_4_lines
	store arg2b, # 4	; в arg2b сохраним счётчик цикла по строкам (4 раза)
loop:	
	ldx arg0b	; для левой половины строки экрана берём индекс тайлов в arg0b
	ldy # 16	; 16 раз надо повторить цикл по строке слева...
loop1:	stx PPU_DATA	; записываем текущий индекс тайла в экранную область
	inx		; и увеличиваем его.
	dey		; уменьшаем счётчик цикла в Y
	bne loop1	; и если он 0 
	stx arg0b	; сохраняем увеличенный индекс тайла обратно в arg0b
	
	ldx arg1b	; теперь идёт правая половина строки на экране
	ldy # 16	; опять 16 раз надо повторить
loop2:	stx PPU_DATA	; запись в экранную область индекса тайла
	inx		; и его инкремент.
	dey		; опять уменьшаем счётчик цикла в Y
	bne loop2	; и повторяем итерацию если он не достиг нуля
	stx arg1b	; сохраняем индеса тайла для правой половины экрана в arg1b
	; здесь мы достигли следующей строки (залили 32 байта)
	dec arg2b	; уменьшаем счётчик цикла по строкам
	bne loop	; и если он не достиг нуля - продолжаем цикл
	rts		; возвращаемся из процедуры
.endproc

; fill_8_lines - заполнить 8 строк экрана нарастающими в правой и в левой половинах
; экрана индексами тайлов так чтобы покрыть все 256 возможных индексов тайлов
; заполнив 8 строк экрана (8*32=256) таким паттерном чтобы вывести битмап 256x64 пикселя
; из MMC3_CHR_H0 и MMC3_CHR_H1 как мы сохранили в тайлсете.
.proc fill_8_lines
	; тайлсет упорядочен таким образом, что битмап состоит из четырёх
	; областей разбросанных справа и слева на экране в четыре области которые надо
	; вывести в два захода по 4 строки за раз процедурой fill_4_lines:
	store arg0b, # 0	; первая левая четверть начинается с тайла 0
	store arg1b, # 64	; первая правая четверть начинается с тайла 64
	jsr fill_4_lines	; выводим первые 4 строки
	store arg0b, # 128	; вторая левая четверть начинается с тайла 128
	store arg1b, # 192	; вторая правая четверть начинается с тайла 192
	jsr fill_4_lines	; выводим вторые 4 строки
	rts			; возвращаемся из процедуры.
.endproc

; fill_32_lines - вызовем четыре раза подряд fill_8_lines
.proc fill_32_lines
	jsr fill_8_lines
	jsr fill_8_lines
	jsr fill_8_lines
	jsr fill_8_lines
	rts
.endproc

; irq - процедура обработки прерывания IRQ.
; Она вызывается при наступлении прерывания от MMC3, т.е. по счётчику строк.
; Сперва в теле основного цикла в VBlank мы настроим отображение страниц на начало
; данных битмапа в тайлсете.
; Далее при выводе кадра начнут отсчитываться сканлайны и данная процедура вызовется
; 3 раза - и в ней мы будем сменять отображение страниц в данные тайлов (CHR) и
; тем самым будем менять тайлсет на лету чтобы на экране сформировалась большая
; картинка из уникальных пикселей.
; На входе в next_page хранится номер банка видеоданных на который надо переключиться.
.proc irq
	pha		; сохраняем аккумулятор в стек
	txa		; помещаем X в A
	pha		; сохраняем снова A (т.е. X) в стек
	; выключаем прерывание MMC3 и одновременно этим сбрасываем флаг
	; наступившего прерывания, иначе прерывание будет генерироваться
	; каждый сканлайн!
	sta MMC3_IRQ_OFF
	; при данной конфигурации видео (из какой половины CHR берутся данные
	; для фона, а из какой - для спрайтов) прерывание срабатывает в самом конце
	; строки в её периоде HBlank и достаточно поздно чтобы мы в этот HBlank уже
	; могли обновлять параметры видео без видимых глюков. 
	; поэтому нам придётся подождать следующего HBlank искуственной паузой
	ldx # 15	; меняя количество холостых циклов на 10 или 20 вы
loop:	dex		; можете увидеть как с разных концов экрана будут
	bne loop	; появляться глюки
	; сменим банк тайловых данных в первой половине CHR на новый:
	mmc3_set_bank_page # MMC3_CHR_H0, next_page
	; с этой точки точные тайминги уже не критичны, т.к. видеочип
	; будет занят отрисовкой уже настроенной первой половины CHR
	inc next_page	; увеличим текущий банк на два, т.к. мы 
	inc next_page	; работаем в режиме половинок, а не четвертей.
	; и выставим следующий банк в CHR_H1:
	mmc3_set_bank_page # MMC3_CHR_H1, next_page
	inc next_page	; и опять увеличим текущий банк графики
	inc next_page	; на две четверти вперёд
	; Следущее прерывание должно сработать через 64 строки далее, но т.к.
	; мы ждали пропуска строки, то надо загрузить в счётчик на 1 меньше - 63
	store MMC3_IRQ_COUNTER, # 63
	sta MMC3_IRQ_ON	; включим прерывания MMC3
	
	pla		; восстановим A из стека
	tax		; и скопируем в X, т.к. это был он
	pla		; а теперь восстановим A
	rti		; Инструкция возврата из прерывания
.endproc

; reset - стартовая точка всей программы - диктуется вторым адресом в сегменте 
; VECTORS оформлена как процедура, но вход в неё происходит при включении консоли 
; или сбросу её по кнопке RESET, поэтому ей некуда "возвращаться" и она 
; принудительно инициализирует память и стек чтобы работать с чистого листа.
.proc reset
	; ***********************************************************
	; * Первым делом нужно привести систему в рабочее состояние *
	; ***********************************************************
	sei			; запрещаем прерывания
	ldx # $FF		; чтобы инициализировать стек надо записать $FF в X
	txs			; и передать его в регистр вершины стека командой 
				; Transfer X to S (txs)
	
	sta MMC3_IRQ_OFF	; Выключим IRQ маппера
	
	; Теперь можно пользоваться стеком, например вызывать процедуры
	jsr warm_up		; вызовем процедуру "разогрева" (см. neslib.s)

	store MMC3_MIRROR, # MMC3_MIRROR_V	; Выставим вертикальное зеркалирование
	store MMC3_RAM_PROTECT, # 0		; Отключим RAM (если бы она даже была)
	
	store_addr arg0w, palettes	; параметр arg0w = адрес наборов палитр
	jsr fill_palettes	; вызовем процедуру копирования палитр в PPU
	
	fill_ppu_addr PPU_SCR0	; настроимся в начало первой видеостраницы
	; и зальём в неё паттерн тайлов выводящий сформированный нами в тайлсете
	; битмап с произвольным изображением
	jsr fill_32_lines	
	; заливка 32 строк будет заливать 2 лишних строки (всего из 30, а не 32)
	; и потому просто затрёт область атрибутов экранной области SCR0
	; поэтому нам надо перенастроить PPU_ADDR чтобы выставить правильные палитры:
	fill_ppu_addr PPU_SCR0_ATTRS	; настроимся на атрибуты первой видеостраницы
	lda # 0				; выберем в A нулевую палитру
	jsr fill_attribs		; и зальём её область атрибутов SCR0

	; Спрайты должны быть включены даже если они не нужны, иначе счётчик
	; сканлайнов в MMC3 не будет работать, поэтому отключим все спрайты 
	; выводом их за границу отрисовки по Y
	ldx # 0		; В X разместим указатель на текущий спрайт
	lda # $FF	; В A координата $FF по Y
sz_loop:	
	sta SPR_TBL, x	; Сохраним $FF в координату Y текущего спрайта
	inx
	inx
	inx
	inx		; И перейдём к следующему
	bne sz_loop	; Если X не 0, то идём на следующую итерацию
	
	; **********************************************
	; * Стартуем видеочип и запускаем все процессы *
	; **********************************************
	; Включим генерацию прерываний по VBlank и источником тайлов для спрайтов
	; сделаем второй банк видеоданных
	store PPU_CTRL, # PPU_VBLANK_NMI | PPU_SPR_TBL_1000
	; Включим отображение спрайтов и то что они отображаются в левых 8 столбцах пикселей
	store PPU_MASK, # PPU_SHOW_BGR | PPU_SHOW_LEFT_BGR | PPU_SHOW_SPR | PPU_SHOW_LEFT_SPR
	cli		; Разрешаем прерывания
	
	; ***************************
	; * Основной цикл программы *
	; ***************************
main_loop:
	jsr wait_nmi		; ждём наступления VBlank

	; Чтобы обновить таблицу спрайтов в видеочипе надо записать в OAM_ADDR ноль
	store OAM_ADDR, # 0
	; И активировать DMA записью верхнего байта адреса страницы с описаниями
	store OAM_DMA, # >SPR_TBL

	; В начале кадра выставим в половинках банков графики CHR0 
	; банки с номерами 8..9..10..11 (т.к. мы работаем половинками, 
	; а не четвертинками, то нечеты не указываются явно)
	mmc3_set_bank_page # MMC3_CHR_H0, # 8
	mmc3_set_bank_page # MMC3_CHR_H1, # 10
	; Следующий банк видеоданных на который надо переключится в 
	; прерывании - 12 и мы будем хранить его в next_page:
	store next_page, # 12
	; Счётчик сканлайнов маппера надо выставить в 63, а не 64, т.к. процедура
	; прерывания будет сама пропускать один сканлайн:
	store MMC3_IRQ_COUNTER, # 63
	; Выставим флаг того, что на следующем сканлайне надо перезагрузить
	; счётчик сканлайнов значением из IRQ_COUNTER
	sta MMC3_IRQ_RELOAD
	; Включим генерацию прерывания IRQ маппером
	sta MMC3_IRQ_ON
	
	store PPU_SCROLL, # 0	; Перед началом кадра выставим скроллинг
	store PPU_SCROLL, # 0	; в (0, 0) чтобы панель рисовалась фиксированно
	
	; ********************************************************
	; * После работы с VRAM можно заняться другими вещами... *
	; ********************************************************

	jsr update_keys		; Обновим состояние кнопок опросив геймпады

	jmp main_loop		; И уходим ждать нового VBlank в бесконечном цикле
.endproc
